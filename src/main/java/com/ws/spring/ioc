1 spring ioc 的主要作用：
1） 统一负责对象的创建
2） 管理生命周期
3）自动维护对象的依赖关系

2 依赖查找的方法：
1）按照类型
2）按照名称

依赖注入方式
1） 构造器参数
2） 方法传参
3） 属性 反射
官方说法：
接口注入。 
           接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。
构造方法注入。
	这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。
而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。
setter方法注入。
	因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无法在构造完成后马上进入就绪状态。其实，这些操作都是由IoC容器来做的，
我们所要做的，就是调用IoC容器来获得对象而已。


2 spring ioc 的实现原理：

	所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，
把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，
而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。

Spring的IoC容器在实现控制反转和依赖注入的过程中,可以划分为两个阶段:
容器启动阶段
Bean实例化阶段

Spring中提供了两种IoC容器：

BeanFactory
ApplicationContext

	BeanFactory。基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。
所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。
	ApplicationContext。ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，
ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等，ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。
所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场中，ApplicationContext类型的容器是比较合适的选择。

无论使用哪个容器，我们都需要通过某种方法告诉容器关于对象依赖的信息，只有这样，容器才能合理的创造出对象：

通过最基本的文本文件来记录被注入对象和其依赖对象之间的对应关系
通过描述性较强的XML文件格式来记录对应信息
通过编写代码的方式来注册这些对应信息
通过注解方式来注册这些对应信息

虽然提供了四种方式，但是我们一般只使用xml文件方式和注解方式

 容器创造对象的第一步，那就是加载配置文件信息，我们已经知道我们主要通过xml文件和注解的方式来告诉容器对象间的依赖信息，那么容器怎么才能从xml配置文件中得到对象依赖的信息呢？
 
 	在BeanFactory容器中，每一个注入对象都对应一个BeanDefinition实例对象，该实例对象负责保存注入对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。
 当客户端向BeanFactory请求相应对象的时候，BeanFactory会通过这些信息为客户端返回一个完备可用的对象实例。
那么BeanDefinition实例对象的信息是从哪而来呢？这里就要引出一个专门加载解析配置文件的类了，他就是BeanDefinitionReader，对应到xml配置文件，就是他的子类XmlBeanDefinitionReader，
XmlBeanDefinitionReader负责读取Spring指定格式的XML配置文件并解析，之后将解析后的文件内容映射到相应的BeanDefinition。
在我们了解了怎么得到对象依赖的信息，并知道这些信息最终保存在BeanDefinition之后，我们可能会想，那么容器怎么通过这些信息创造出一个可用的对象了呢？

BeanFactory 通过实现接口 BeanDefinitionRegistry 通过BeanDefinitionRegistry的rsgisterBeanDefinition(BeanDefinition beandefinition)方法来进行Bean的注册。

	我们来总结一下一个Bean是如何注册到容器中，然后被我们获取的：首先我们需要配置该Bean的依赖信息，通常我们配置在xml文件中，然后我们通过XmlBeanDefinitionReader读取文件内容，
然后将文件内容映射到相应的BeanDefinition，然后我们可以通过BeanFactory和BeanDefinitionRegistry的具体实现类,比如DefaultListableBeanFactory实现Bean的注册和获取。







